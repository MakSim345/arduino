How to setup arduino timer to get 1 microsecond interval

Setting up an Arduino timer to achieve a 1-microsecond interval involves configuring one of the hardware timers on the microcontroller (e.g., ATmega328P on an Arduino Uno) to generate an interrupt or toggle a pin at precise 1 µs intervals.

This requires low-level manipulation of timer registers, as the Arduino’s high-level functions like 'millis()' or 'delay()' are too coarse for microsecond precision over repeated intervals.

### Key Concepts
1. **Timer Basics**:
   - Arduino Uno uses an ATmega328P, which runs at 16 MHz (16,000,000 cycles per second).
   - 1 µs = 1/1,000,000 seconds, so at 16 MHz, 1 µs corresponds to 16 clock cycles (16,000,000 Hz × 0.000001 s = 16 cycles).

2. **Available Timers**:
   - ATmega328P has three timers:
     - Timer0 (8-bit): Used by 'millis()' and 'delay()'.
     - Timer1 (16-bit): More precise, ideal for this task.
     - Timer2 (8-bit): Often used for PWM.
   - We’ll use **Timer1** because its 16-bit counter allows finer control and longer intervals if needed.

3. **Timer Modes**:
   - We’ll use **CTC (Clear Timer on Compare Match)** mode, where the timer counts up to a specified value (OCR1A), resets to 0, and triggers an interrupt.

4. **Prescaler**:
   - The prescaler divides the 16 MHz clock to slow down the timer ticks.
   - Options: 1 (no prescaler), 8, 64, 256, 1024.
   - For 1 µs resolution, we’ll use no prescaler (1), so each tick = 1/16,000,000 s = 62.5 ns.

5. **Math**:
   - Goal: Interrupt every 1 µs = 16 clock cycles (at 16 MHz with no prescaler).
   - In CTC mode, the timer counts from 0 to OCR1A (inclusive), so we set OCR1A = 15 (since 0 to 15 = 16 cycles).

---

### Example Code
How to configure Timer1 to trigger an interrupt every 1 µs on an Arduino Uno:

====================================================================================================
#include <avr/io.h>
#include <avr/interrupt.h>

volatile uint32_t microseconds = 0; // Counter for microseconds

// Interrupt Service Routine for Timer1 Compare Match A
ISR(TIMER1_COMPA_vect)
{
    microseconds++; // Increment every 1 µs
}

void setup()
{
    // Disable global interrupts during setup
    cli();

    // Reset Timer1 control registers
    TCCR1A = 0; // Normal port operation, no PWM
    TCCR1B = 0; // Stop timer initially

    // Set Timer1 to CTC mode (Clear Timer on Compare Match)
    TCCR1B |= (1 << WGM12); // WGM12 = 1 for CTC mode (WGM13:0 = 0100)

    // Set prescaler to 1 (no prescaler)
    TCCR1B |= (1 << CS10); // CS10 = 1, CS11 = 0, CS12 = 0

    // Set compare match value for 1 µs
    OCR1A = 15; // 16 cycles (0 to 15) at 16 MHz = 1 µs

    // Enable Timer1 Compare Match A interrupt
    TIMSK1 |= (1 << OCIE1A); // OCIE1A = 1

    // Enable global interrupts
    sei();

    // Start serial for output
    Serial.begin(9600);
}

void loop()
{
    // Print microseconds every second (for demonstration)
    static uint32_t lastPrint = 0;
    if (microseconds - lastPrint >= 1000000)
    {
        // Every 1,000,000 µs = 1 s
        Serial.print("Microseconds: ");
        Serial.println(microseconds);
        lastPrint = microseconds;
    }
}

====================================================================================================

### Detailed Explanation

#### 1. **Registers Used**
- **TCCR1A**: Timer/Counter Control Register A
  - Set to 0 since we don’t need PWM or output toggling (normal port operation).

- **TCCR1B**: Timer/Counter Control Register B
  - 'WGM12 = 1': Enables CTC mode (Waveform Generation Mode = 4).
  - 'CS10 = 1': Sets prescaler to 1 (clock runs at 16 MHz).

- **OCR1A**: Output Compare Register A
  - Set to 15. Timer counts from 0 to 15 (16 ticks), then resets and triggers the interrupt.

- **TIMSK1**: Timer Interrupt Mask Register
  - 'OCIE1A = 1': Enables the Compare Match A interrupt.

#### 2. **Interrupt Setup**
- 'ISR(TIMER1_COMPA_vect)': Defines the ISR for Timer1’s Compare Match A interrupt.
- Each time the timer reaches 15 (after 16 cycles = 1 µs), it resets to 0 and calls this ISR.
- 'microseconds++': Tracks elapsed time in microseconds.

#### 3. **Clock and Timing**
- Clock = 16 MHz, prescaler = 1 → 1 tick = 62.5 ns.
- 16 ticks × 62.5 ns = 1 µs.
- OCR1A = 15 ensures the timer resets and interrupts exactly every 1 µs.

#### 4. **Global Interrupts**
- 'cli()': Disables interrupts during setup to prevent premature triggering.
- 'sei()': Enables interrupts after setup is complete.

#### 5. **Loop**
- Prints the 'microseconds' counter every second (1,000,000 µs) to verify timing.


### Verification
- Upload the code to an Arduino Uno.
- Open the Serial Monitor (9600 baud).
- You’ll see 'microseconds' incrementing by ~1,000,000 every second, confirming 1 µs intervals.

### Practical Considerations
1. **Interrupt Overhead**:
   - The ISR takes a few cycles to execute (e.g., saving registers, jumping). At 1 µs intervals, this overhead might slightly skew timing. Keep the ISR short!
2. **Max Count**:
   - Timer1 is 16-bit, so it maxes out at 65,535. With OCR1A = 15, it’s not a limit here, but 'microseconds' (a 32-bit variable) overflows after ~4,294 seconds (~71 minutes).
3. **Other Timers**:
   - Timer0 (used by 'millis()') isn’t affected, so 'millis()' still works.
4. **Pin Output**:
   - To toggle a pin every 1 µs, modify TCCR1A for CTC with toggle mode ('COM1A0 = 1') and use pin 9 (OC1A).

---

### Alternative: Pin Toggle Example
To toggle a pin (e.g., pin 9) every 1 µs instead of counting:

====================================================================================================
#include <avr/io.h>
#include <avr/interrupt.h>

void setup()
{
    // Set pin 9 (OC1A) as output
    DDRB |= (1 << DDB1); // PB1 = pin 9

    cli();
    TCCR1A = 0;
    TCCR1B = 0;
    TCCR1A |= (1 << COM1A0); // Toggle OC1A on compare match
    TCCR1B |= (1 << WGM12);  // CTC mode
    TCCR1B |= (1 << CS10);   // Prescaler = 1
    OCR1A = 15;              // 1 µs interval
    sei();
}

void loop()
{
    // Do nothing; pin 9 toggles automatically
}
====================================================================================================

Now, Pin 9 will toggle every 1 µs (500 kHz square wave), observable with an oscilloscope.

This setup gives a precise 1 µs timing with Timer1.
